#include <QCoreApplication>
#include "function.h"
#include "test_iscurrentorderofmultipliers.h"

int main(int argc, char *argv[])
{
    QCoreApplication a(argc, argv);

    Test_isCurrentOrderOfMultipliers test;
    QTest::qExec(&test);

    // Получить строку постфиксной записи выражения из исходного файла
    // Если найдена ошибка чтения
        // Вывести сообщение об ошибке и завершить работу программы

    // ...Считать список ошибок пустым
    // Если в полученной строке нет операторов сравнения
        // Считать, что найдена ошибка NO_COMPARISON_OPERATOR, добавить её в список ошибок
    // ИначеЕсли в полученной строке несколько операторов сравнения
        // Считать, что найдена ошибка MULTIPLE_COMPARISON_OPERATORS, добавить её в список ошибок

    // Из постфиксной записи выражения получить дерево этого выражения

    // Если найдены ошибки в построении дерева
        // Вывести ошибки и завершить работу программы

    // Получить инфиксную запись выражения из дерева этого выражения

    // Вывести в выходной файл инфиксную запись выражения

    // Если найдена ошибка записи
        // Вывести сообщение об ошибке и завершить работу программы

    // Перестроить дерево выражения, перенеся все слагаемые после знака сравнения в левую часть (не)равенства (до знака сравнения)
    // Отсортировать слагаемые и множители (не)равенства по алфавиту, начиная левого операнда корня дерева выражения

    // Из дерева выражения получить инфиксную запись этого выражения

    // Вывести в выходной файл инфиксную запись выражения

    return a.exec();
}


/*!
 * \brief Из постфиксной записи выражения получить дерево этого выражения
 * \param [in] expr － строка выражения в постфиксной записи
 * \param [out] errors － обнаруженные ошибки в постфиксной записи
 * \return указатель на корень построенного дерева
 */
NodeOfExprTree* postfixToTree(QString expr, QSet<Error> errors)
{
    // ...Считать стек узлов пустым

    // Разбить строку на токены

    // ...Считать, что не было найдено ошибок
    // Для каждого токена
    {
        // Если текущий токен имеет табуляцию или перевод строки
            // Считать, что найдена ошибка UNCORRECT_DELIMITER для текущего токена, добавить её в список ошибок
        // ИначеЕсли текущий токен некорректен
            // Считать, что найдена ошибка INVALID_SEQUENCE для текущего токена, добавить её в список ошибок
    }
    // Если были найдены ошибки
    // Вернуть пустой корень дерева

    // Для каждого токена
    {
        // Создать узел для текущего токена
        // Определить тип созданного узла

        // Если тип созданного узла есть переменная или число
            // Добавить узел в стек узлов

        // ИначеЕсли тип созданного узла есть оператор
            // Если созданный узел типа оператора сравнения и текущий токен не яляется последним
                // Считать, что найдена ошибка COMPARISON_OPERATOR_IN_PARENTHESES, добавить её в список ошибок

            // Если в стеке есть необходимое кол-во узлов для текущего типа узла
                // Вытащить необходимое кол-во узлов из стека и считать их операндами созданного узла
                // Добавить созданный узел в стек
            // Иначе считать, что найдена ошибка NOT_ENOUGH_OPERANDS, добавить её в список ошибок и вернуть пустой корень дерева
    }

    // Если в стеке больше одного узла
        // Считать, что найдена ошибка MISSING_OPERATOR, добавить её в список ошибок и вернуть пустой корень дерева

    // Вернуть корень дерева
    return nullptr;
}

/*!
 * \brief Определить является ли строка числом
 * \param [in] token - проверяемый токен
 * \return true, если токен есть число, иначе - false
 */
bool isNum(QString token)
{
    // ...Считать, что заданный токен есть число
    bool is_num = true;

    /* Если первый символ заданного токена есть цифра 0 и второй символ - не есть плавающая запятая
     или первый символ есть НЕцифра */
    if (token[0] == '0' && token[1] != ',' || !token[0].isNumber())
    {
        // Считать, что заданный токен не число, и завершить работу функции
        is_num = false;
    }

    // Считать, что в токене нет плавающей запятой
    bool has_comma = false;
    int num_of_symbol = token.length();
    for(int i = 1; i < num_of_symbol && is_num; i++) // Для каждого символа токена, кроме первого, и пока заданный токен число
    {
        // Если текущий символ есть запятая и она не была ещё найдена
        if (token[i] == ',' && has_comma == false)
        {
            // Считать, что в токене есть плавающая запятая
            has_comma = true;
        }
        // ИначеЕсли текущий символ есть запятая и она уже была найдена или текущий символ не есть цифра
        else if (token[i] == ',' && has_comma == true || !token[i].isNumber())
        {
            // Считать, что заданный токен не число
            is_num = false;
        }
    }

    // Вернуть результат - заданный токен число или нет
    return is_num;
}

/*!
 * \brief Определить является ли токен переменной
 * \param [in] token - проверяемый токен
 * \return true, если токен есть переменная, иначе - false
 */
bool isVar(QString token)
{
    QString latin_alphabet("ABCDIFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxwz");
    // Считать, что заданный токен является именем переменной
    bool is_var = true;

    // Если первый символ не является буквой латинского алфавита и нижним подчёркиванием
    if (latin_alphabet.indexOf(token[0]) == -1 && token[0] != '_')
    {
        // Считать, что заданный токен не является переменной
        is_var = false;
    }

    int num_of_symbol = token.length();
    for(int i = 1; i < num_of_symbol && is_var; i++)// Для каждого символа токена, начиная со второго, и пока заданный токен является переменной
    {
        // Если символ не является буквой латинского алфавита, цифрой и символом нижнего подчёркивания
        if (!token[i].isNumber() && token[0] != '_' && latin_alphabet.indexOf(token[i]) == -1)
        {
            // Считать, что заданный токен не является именем переменной
            is_var = false;
        }
    }

    return is_var;
}

/*!
 * \brief Определить является ли токен оператором
 * \param [in] token - проверяемый токен
 * \return true, если токен есть оператор, иначе - false
 */
bool isOperator(QString token)
{
    // Если токен является
    if (token == "~" || token == "*" || token == "/"
        || token == "+" || token == "-" || token == ">"
        || token == "<" || token == ">=" || token == "<="
        || token == "==" || token == "!=")
        return true;

    return false;
}
