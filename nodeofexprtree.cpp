#include "nodeofexprtree.h"

NodeOfExprTree::NodeOfExprTree()
{
    type = UNDEFINED;
    value = "";
    left_operand = nullptr;
    right_operand = nullptr;
}

NodeOfExprTree::NodeOfExprTree(QString _value, NodeOfExprTree* _left_operand, NodeOfExprTree* _right_operand)
{
    // Установить значение узла
    value = _value;

    // Установить тип узла
    if (value == "~")
        type = UN_MINUS;
    else if (value == "*")
        type = MULTIPLICATION;
    else if (value == "/")
        type = DIVISION;
    else if (value == "+")
        type = PLUS;
    else if (value == "-")
        type = BIN_MINUS;
    else if (value == ">")
        type = GREATER;
    else if (value == "<")
        type = LESS;
    else if (value == ">=")
        type = GREATER_OR_EQUAL;
    else if (value == "<=")
        type = LESS_OR_EQUAL;
    else if (value == "=")
        type = EQUAL;
    else if (value == "!=")
        type = NOT_EQUAL;
    else if (isVar(value))
        type = VAR;
    else if (isNum(value))
        type = NUM;
    else
        type = UNDEFINED;

    // Установить левый операнд
    left_operand = _left_operand;

    // Установить правый операнд
    right_operand = _right_operand;
}

/*!
 * \brief Вернуть тип узла
 * \return тип узла (0-5 в зависимости от приоритета), -1 - ошибка
 */
int NodeOfExprTree::getPrecedenceType()
{
    switch (type) {
    case NUM:
    case VAR:
        return 0;
        break;
    case UN_MINUS:
        return 1;
        break;
    case MULTIPLICATION:
    case DIVISION:
        return 2;
        break;
    case PLUS:
    case BIN_MINUS:
        return 3;
        break;
    case GREATER:
    case LESS:
    case GREATER_OR_EQUAL:
    case LESS_OR_EQUAL:
        return 4;
        break;
    case EQUAL:
    case NOT_EQUAL:
        return 5;
        break;
    default:
        return -1;
        break;
    }
}

/*!
 * \brief Получить строку значения узла для инфикной записи
 * \return строка для инфикной записи
 */
QString NodeOfExprTree::valueToStr()
{
    if(type == UN_MINUS)
        return "-";
    if(type == EQUAL)
        return "==";

    return value;
}

/*!
     * \brief Перегрузка оператора равенства для NodeOfExprTree
     */
bool NodeOfExprTree::operator==(const NodeOfExprTree& other) const
{
    if (value == other.value && type == other.type)
        return true;

    return false;
}

/*!
 * \brief Удалить дерево
 * \param [in] root - корень дерева
 */
void NodeOfExprTree::delTree(NodeOfExprTree* root)
{
    if (root == nullptr) return;
    if (root->left_operand != nullptr) delTree(root->left_operand);
    if (root->right_operand != nullptr) delTree(root->right_operand);

    delete root;
}


/*!
 * \brief Перегрузка оператора больше для OperandOfExpr
 */
bool OperandOfExpr::operator>(const OperandOfExpr& other) const
{
    return false;
}

/*!
 * \brief Расставить все элементы в дереве выражения по алфавиту, начиная с заданного узла
 * \return указатель на корень отсортированного дерева
 */
NodeOfExprTree* NodeOfExprTree::sortOperandsAlphabetically()
{
    // ...Считать корень перестроенного дерева равным заданному узлу
    // Получить список для сортировки

    // Для каждого элемента списка сортировки
    {
        // Если текущий сортировочный элемент не является листом дерева
        // Расставить все элементы в дереве по алфавиту, начиная с текущего элемента сортировки, получив корень этого элемента
        // Если операнд текущего элемента сортировки отличен от полученного корня
        // Изменить операнд текущего элемента сортировки на полученный корень
    }

    // Расставить элементы сортировочного списка по алфавиту...
    // Если в сортировочном списке больше одного элемента
    // Для каждой пары соседних элементов списка сортировки и пока не произошло ни одного изменения
    {
        // Для всех пар соседних неотсортированных элементов сортировки
        {
            // Поменять местами элементы пары, если они нарушают порядок сортировки
        }
    }
    // Перестроить дерево по отсортированным элементам в списке и получить корень перестроенного дерева

    // Вернуть корень дерева
    NodeOfExprTree* left_operand = new NodeOfExprTree("1");
    return left_operand;
}

/*!
 * \brief Определить правильность расстановки двух множителей по алфавиту
 * \param [in] other - второй по порядку элемент
 * \return true, если порядок верный, false - иначе
 */
bool OperandOfExpr::isCurrentOrderOfMultipliers(const OperandOfExpr& other) const
{
    // Получить первый множитель, пропуская и посчитав все узлы, если они есть, типы которых унарные минусы
    // Получить второй множитель, пропуская и посчитав все узлы, если они есть, типы которых унарные минусы

    // Определить, соблюдается ли порядок: сначала числа, потом переменные, далее - выражения в скобках
    // Если типы множителей одинаковые
        // Определить, меньше ли первый множитель второго с учётом всех минусов, если их тип число
        // Определить, меньше ли первый множитель второго, если их тип переменная
        // Определить правильность расстановки множителей, если они есть выражения в скобках

    // Вернуть получившийся результат

    return false;
}

/*!
 * \brief Определить правильность расстановки двух слагаемых по алфавиту
 * \param [in] other - второй по порядку элемент
 * \return true, если порядок верный, false - иначе
 */
bool OperandOfExpr::isCurrentOrderOfSummands(const OperandOfExpr& other) const
{
    // Получить первое слагаемое, пропуская и посчитав все узлы, если они есть, типы которых унарные минусы
    // Получить второе слагаемое, пропуская и посчитав все узлы, если они есть, типы которых унарные минусы

    // Получить список элементов каждого слагаемого

    // Определить, соблюдается ли порядок: сначала слагаемое с одинаковыми внутри себя именами переменных, потом - с различными
    // Вернуть результат, если порядок определился

    // Получить степень каждого слагаемого
    // Определить, соблюдается ли порядок: сначала слагаемое с большей степенью переменных
    // Вернуть результат, если порядок определился

    // Определить, соблюдается ли порядок: по алфавиту, учитывая только имена переменные
    // Вернуть результат, если порядок определился

    // Определить, соблюдается ли порядок: от большего количества элементов слагаемого к меньшему
    // Вернуть результат, если порядок определился

    // Определить, соблюдается ли порядок: от большего количества выражений в скобках в слагаемом к меньшему
    // Вернуть результат, если порядок определился

    // Если слагаемые типа число
        // Определить, соблюдается ли порядок: от большего числа к меньшему
        // Вернуть результат, если порядок определился

    // Вернуть, что порядок верный

    return false;
}

/*!
 * \brief Определить правильность расстановки двух выражений в скобках по алфавиту
 * \param [in] other - второй по порядку узел
 * \return true, если порядок верный, false - иначе
 */
bool OperandOfExpr::isCurrentOrderOfParenthesisedExpressions(const OperandOfExpr& other) const
{
    // Для каждой пары слагаемых выражений и повторять по минимальному кол-ву слагаемых из этих выражений
    {
        // Получить степень обоих слагаемых

        // Определить, соблюдается ли порядок: от большей степени переменной слагаемого к меньшей
        // Вернуть результат, если порядок определился
    }

    // Получить списки элементов каждого выражения
    // Определить, соблюдается ли порядок: по алфавиту, учитывая только переменные
    // Вернуть результат, если порядок определился

    // Определить, соблюдается ли порядок: от большего количества переменных в выражении к меньшему
    // Вернуть результат, если порядок определился

    // Определить, соблюдается ли порядок: от большего количества слагаемых к меньшему
    // Вернуть результат, если порядок определился

    // Вернуть, что порядок верный
    return false;
}

/*!
 * \brief Получить список операндов, родители которых одного приоритета, начиная с заданного корня
 * \return список операндов
 */
QList<OperandOfExpr> NodeOfExprTree::getListOfNodesOfSamePrecedenceLevel()
{
    // ...Считать список операндов пустым
    // ...Считать списки элементов левого и правого операндов пустыми

    // Если заданный узел есть унарная операция
        // Добавить в список операндов заданный узел и его операнд как родитель и операнд элемента соответственно
        // Вернуть список

    // Если заданный узел лист дерева
        // Добавить в список узлов заданный узел
        // Вернуть список

    // Если левый операнд заданного узла того же приоритета, что и заданный узел
        // Получить список элементов операторов одного приоритета, начиная с левого операнда заданного узла, без родителя у первого элемента
        // Добавить полученный список в список элементов левого операнда
    // Иначе добавить левый операнд в список элементов левого операнда

    // Если правый операнд заданного узла того же приоритета, что и заданный узел, несимметричный
        // Получить список элементов операторов одного приоритета, начиная с левого операнда заданного узла, без родителя у первого элемента
        // Добавить полученный список в список элементов правого операнда
    // Иначе добавить правый операнд в список правого операнда  элементов

    // Считать заданный узел родителем первого элемента списка элементов правого операнда

    // Добавить в список операндов списки левого и правого операндов заданного узла

    // Вернуть список операндов


    // Создать общего родителя для множителя : "*"
    QList<OperandOfExpr> list = {OperandOfExpr{nullptr, new NodeOfExprTree("1"), true},
                                   OperandOfExpr{new NodeOfExprTree("*"), new NodeOfExprTree("a"), false},
                                   OperandOfExpr{new NodeOfExprTree("*"), new NodeOfExprTree("2"), false},
                                   OperandOfExpr{new NodeOfExprTree("*"), new NodeOfExprTree("b"), false}};

    return list;
}

/*!
 * \brief Получить список операндов, родители которых одного приоритета, начиная с заданного узла, раскрывая скобки
 * \param [in] is_invert - флаг: true - значение заданного узла необходимо поменять на противоположный операнд, false - иначе
 * \return список операндов
 */
QList<OperandOfExpr> NodeOfExprTree::getNodesOfSamePrecedenceWithParenthesesOpening(bool is_invert)
{
    // ...Считать список операндов пустым
    // ...Считать списки элементов левого и правого операндов пустыми

    // Если заданный узел есть унарная операция
        // Добавить в список операндов заданный узел и его операнд как родитель и операнд элемента соответственно
        // Вернуть список

    // Если заданный узел лист дерева
        // Добавить в список узлов заданный узел
        // Вернуть список

    // Если левый операнд заданного узла того же приоритета, что и заданный узел
        // Получить список элементов операторов одного приоритета с учётом инвертации, начиная с левого операнда заданного узла, без родителя у первого элемента
        // Добавить полученный список в список элементов левого операнда
    // Иначе добавить левый операнд в список элементов

    // Инвертировать тип заданного узла, если флаг установлен
    // Если заданный узел несимметричный оператор и флаг инвертации не установлен
        // Установить флаг инвертации
    // ИначеЕсли заданный узел симметричный оператор и флаг инвертации установлен
        // Убрать флаг инвертации

    // Если правый операнд заданного узла того же приоритета, что и заданный узел
        // Получить список элементов операторов одного приоритета с учётом инвертации, начиная с левого операнда заданного узла, без родителя у первого элемента
        // Добавить полученный список в список элементов правого операнда
    // Иначе добавить правый операнд в список правого операнда элементов

    // Считать заданный узел родителем первого элемента списка элементов правого операнда

    // Добавить в список операндов списки левого и правого операндов заданного узла

    // Вернуть список операндов

    // Создать общего родителя для множителя : "*"
    QList<OperandOfExpr> list = {OperandOfExpr{nullptr, new NodeOfExprTree("1"), true},
                                   OperandOfExpr{new NodeOfExprTree("*"), new NodeOfExprTree("a"), false},
                                   OperandOfExpr{new NodeOfExprTree("*"), new NodeOfExprTree("2"), false},
                                   OperandOfExpr{new NodeOfExprTree("*"), new NodeOfExprTree("b"), false}};

    return list;
}

/*!
 * \brief Построить дерево выражения по элементам в списке
 * \param [in] list - список
 * \return указатель на корень дерева
 */
NodeOfExprTree* NodeOfExprTree::listToTree(QList<OperandOfExpr>& list)
{
    // Если первый элемент списка не является первым элементом дерева
    // Сделать первый элемент списка первым элементом дерева

    // Считать операнд первого элемента списка left_operand
    // Для каждого элемента списка кроме первого
    {
        // Если текущий элемент является первым элементом дерева
        // Создать симметричный узел того же приоритета и считать его родителем текущего узла
        // Установить left_operand как левый операнд родителя текущего элемента списка
        // Считать родитель текущего элемента списка left_operand
    }

    // Вернуть родитель последнего элемента
    QSet<Error> errors;
    return postfixToTree("1 2 + 3 -", errors);
}

/*!
 * \brief Получить список элементов сортировки в дереве, начиная с заданного узла
 * \return список элементов сортировки
 */
QList<OperandOfExpr> NodeOfExprTree::getSortedList()
{
    //... Считать список узлов одного уровня приоритета пустым

    // Если заданный узел есть узел типа оператора слагаемаго
        // Получить список слагаемых и добавить его в список узлов одного уровня приоритета
    // ИначеЕсли заданный узел типа оператора множителя
        // Получить список множителей и добавить его в список узлов одного уровня приоритета
    // ИначеЕсли заданный узел есть унарный оператор
        // Считать родителя и операнд единственного элемента в списке узлов заданным узлом и его непустым операндом соответственно

    // Вернуть список узлов одного уровня приоритета

    QList<OperandOfExpr> list = {OperandOfExpr{nullptr, new NodeOfExprTree("1"), true},
                                 OperandOfExpr{new NodeOfExprTree("*"), new NodeOfExprTree("a"), false},
                                 OperandOfExpr{new NodeOfExprTree("*"), new NodeOfExprTree("2"), false},
                                 OperandOfExpr{new NodeOfExprTree("*"), new NodeOfExprTree("b"), false}};

    return list;
}

/*!
 * \brief Получить инфиксную запись выражения из дерева этого выражения
 * \param [in] is_first_elem - флаг: true - указанный узел является первым операндом родителя, false - иначе
 * \return строка инфиксной записи выражения
 */
QString NodeOfExprTree::treeToInfix(bool is_first_elem)
{
    bool is_first_elem_for_operand = false;
    bool is_expr_in_parentheses = false;

    // ...Считать строку инфиксной записи пустой
    QString infix;
    QString infix_of_left_operand;
    QString infix_of_right_operand;

    // Если у заданного узла есть левый операнд
    if(left_operand != nullptr)
    {
        // Получить инфиксную запись левого операнда заданного узла, установив флаг первого элемента, если заданный оператор большего приоритета, чем левый операнд, или он уже установлен
        infix_of_left_operand = left_operand->treeToInfix(is_first_elem_for_operand);

        /* Если левый операнд заданного узла типа оператора унарный минус и не является первым элементом выражения
         или является узлом типа оператора меньшего приоритета, чем приоритет типа оператора заданного узла*/
        is_expr_in_parentheses = (left_operand->type == UN_MINUS && !is_first_elem_for_operand)
                                 || (getPrecedenceType() < left_operand->getPrecedenceType() && left_operand->type != NUM
                                     && left_operand->type != VAR && !isComparisonOperator(value));
        if(is_expr_in_parentheses)
        {
            // Взять полученную запись в скобки
            infix_of_left_operand = "(" + infix_of_left_operand + ")";
            is_expr_in_parentheses = false;
        }
        // Добавить в инфиксную запись выражения получившуюся инфиксную запись левого операнда заданного узла
        infix += infix_of_left_operand + " ";
        is_first_elem_for_operand = false;
    }

    // Добавить в инфиксную запись выражения значение заданного узла
    infix += valueToStr();
    if(type != NUM && type != VAR && type != UN_MINUS) infix += " ";

    // Если у заданного узла есть правый операнд
    if(right_operand != nullptr)
    {
        // Получить инфиксную запись правого операнда заданного узла, установив флаг первого элемента, если заданный оператор большего приоритета, чем правый операнд
        infix_of_right_operand = right_operand->treeToInfix(is_first_elem_for_operand);

        /* Если правый операнд заданного узла типа унарный минус или
        заданный узел есть несимметричный узел, а правый операнд типа оператора приоритета не больше заданного узла */
        is_expr_in_parentheses = right_operand->type == UN_MINUS
                                 || ((getPrecedenceType() < right_operand->getPrecedenceType()
                                    || (!isSymmetricOperator() && right_operand->getPrecedenceType() == getPrecedenceType()))
                                     && right_operand->type != NUM && right_operand->type != VAR && !isComparisonOperator(value));
        if(is_expr_in_parentheses)
        {
            // Взять полученную запись в скобки
            infix_of_right_operand = "(" + infix_of_right_operand + ")";
        }
        // Добавить в инфиксную запись выражения получившуюся инфиксную запись правого операнда заданного узла
        infix += infix_of_right_operand;
    }

    // Вернуть инфиксную запись выражения
    return infix;
}

/*!
 * \brief Получить степень выражения
 * \return степень выражения
 */
int NodeOfExprTree::getDegreeOfExpr()
{
    // Считать степень выражения нулевой
    int degree = 0;
    // Считать степень левого и правого операндов заданного узла нулевой
    int degree_of_left_operand = 0;
    int degree_of_right_operand = 0;

    // Считать степень равную единице, если заданный узел есть узел типа переменная, и вернуть её
    if(type == VAR) return 1;
    // Считать степень равную нулю, если заданный узел есть узел типа число, и вернуть её
    if(type == NUM) return 0;

    // Получить степени левого и правого операндов заданного узла
    if(left_operand) degree_of_left_operand = left_operand->getDegreeOfExpr();
    if(right_operand) degree_of_right_operand = right_operand->getDegreeOfExpr();

    // Если заданный узел есть типа оператора сложения или сравнения
    if(type == PLUS || type == BIN_MINUS || isComparisonOperator(value))
    {
        // Считать степень выражения максимальной среди степеней левого и правого операндов заданного узла
        if(degree_of_left_operand >= degree_of_right_operand)
            degree += degree_of_left_operand;
        else
            degree += degree_of_right_operand;
    }
    else
    {
        // Прибавить к степени выражения степень левого операнда заданного узла
        degree += degree_of_left_operand;
        // Если заданный узел типа оператора деление
        if(type == DIVISION)
        {
            // Отнять от степени выражения степень правого операнда заданного узла
            degree -= degree_of_right_operand;
        }
        else
        {
            // Прибавить от степени выражения степень правого операнда заданного узла
            degree += degree_of_right_operand;
        }
    }

    // Вернуть степень выражения
    return degree;
}
