#include "nodeofexprtree.h"

NodeOfExprTree::NodeOfExprTree()
{
    type = UNDEFINED;
    value = "";
    left_operand = nullptr;
    right_operand = nullptr;
}

NodeOfExprTree::NodeOfExprTree(QString _value, NodeOfExprTree* _left_operand, NodeOfExprTree* _right_operand)
{
    // Установить значение узла
    value = _value;

    // Установить тип узла
    if (value == "~")
        type = UN_MINUS;
    else if (value == "*")
        type = MULTIPLICATION;
    else if (value == "/")
        type = DIVISION;
    else if (value == "+")
        type = PLUS;
    else if (value == "-")
        type = BIN_MINUS;
    else if (value == ">")
        type = GREATER;
    else if (value == "<")
        type = LESS;
    else if (value == ">=")
        type = GREATER_OR_EQUAL;
    else if (value == "<=")
        type = LESS_OR_EQUAL;
    else if (value == "==")
        type = EQUAL;
    else if (value == "!=")
        type = NOT_EQUAL;
    else if (isVar(value))
        type = VAR;
    else if (isNum(value))
        type = NUM;
    else
        type = UNDEFINED;

    // Установить левый операнд
    left_operand = _left_operand;

    // Установить правый операнд
    right_operand = _right_operand;
}

/*!
     * \brief Перегрузка оператора равенства для NodeOfExprTree
     */
bool NodeOfExprTree::operator==(const NodeOfExprTree& other) const
{
    if (value == other.value && type == other.type)
        return true;

    return false;
}

/*!
 * \brief Удалить дерево
 * \param [in] root - корень дерева
 */
void NodeOfExprTree::delTree(NodeOfExprTree* root)
{
    if (root == nullptr) return;
    if (root->left_operand != nullptr) delTree(root->left_operand);
    if (root->right_operand != nullptr) delTree(root->right_operand);

    delete root;
}

/*!
 * \brief Определить правильность расстановки двух множителей по алфавиту
 * \param [in] other - второй по порядку элемент
 * \return true, если порядок верный, false - иначе
 */
bool OperandOfExpr::isCurrentOrderOfMultipliers(const OperandOfExpr& other) const
{
    // Получить первый множитель, пропуская и посчитав все узлы, если они есть, типы которых унарные минусы
    // Получить второй множитель, пропуская и посчитав все узлы, если они есть, типы которых унарные минусы

    // Определить, соблюдается ли порядок: сначала числа, потом переменные, далее - выражения в скобках
    // Если типы множителей одинаковые
        // Определить, меньше ли первый множитель второго с учётом всех минусов, если их тип число
        // Определить, меньше ли первый множитель второго, если их тип переменная
        // Определить правильность расстановки множителей, если они есть выражения в скобках

    // Вернуть получившийся результат

    return false;
}

/*!
 * \brief Определить правильность расстановки двух слагаемых по алфавиту
 * \param [in] other - второй по порядку элемент
 * \return true, если порядок верный, false - иначе
 */
bool OperandOfExpr::isCurrentOrderOfSummands(const OperandOfExpr& other) const
{
    // Получить первое слагаемое, пропуская и посчитав все узлы, если они есть, типы которых унарные минусы
    // Получить второе слагаемое, пропуская и посчитав все узлы, если они есть, типы которых унарные минусы

    // Получить список элементов каждого слагаемого

    // Определить, соблюдается ли порядок: сначала слагаемое с одинаковыми внутри себя именами переменных, потом - с различными
    // Вернуть результат, если порядок определился

    // Получить степень каждого слагаемого
    // Определить, соблюдается ли порядок: сначала слагаемое с большей степенью переменных
    // Вернуть результат, если порядок определился

    // Определить, соблюдается ли порядок: по алфавиту, учитывая только имена переменные
    // Вернуть результат, если порядок определился

    // Определить, соблюдается ли порядок: от большего количества элементов слагаемого к меньшему
    // Вернуть результат, если порядок определился

    // Определить, соблюдается ли порядок: от большего количества выражений в скобках в слагаемом к меньшему
    // Вернуть результат, если порядок определился

    // Если слагаемые типа число
        // Определить, соблюдается ли порядок: от большего числа к меньшему
        // Вернуть результат, если порядок определился

    // Вернуть, что порядок верный

    return false;
}

/*!
 * \brief Определить правильность расстановки двух выражений в скобках по алфавиту
 * \param [in] other - второй по порядку узел
 * \return true, если порядок верный, false - иначе
 */
bool OperandOfExpr::isCurrentOrderOfParenthesisedExpressions(const OperandOfExpr& other) const
{
    // Для каждой пары слагаемых выражений и повторять по минимальному кол-ву слагаемых из этих выражений
    {
        // Получить степень обоих слагаемых

        // Определить, соблюдается ли порядок: от большей степени переменной слагаемого к меньшей
        // Вернуть результат, если порядок определился
    }

    // Получить списки элементов каждого выражения
    // Определить, соблюдается ли порядок: по алфавиту, учитывая только переменные
    // Вернуть результат, если порядок определился

    // Определить, соблюдается ли порядок: от большего количества переменных в выражении к меньшему
    // Вернуть результат, если порядок определился

    // Определить, соблюдается ли порядок: от большего количества слагаемых к меньшему
    // Вернуть результат, если порядок определился

    // Вернуть, что порядок верный
    return false;
}

/*!
 * \brief Получить список операндов, родители которых одного приоритета, начиная с заданного корня
 * \return список операндов
 */
QList<OperandOfExpr> NodeOfExprTree::getListOfNodesOfSamePrecedenceLevel()
{
    // ...Считать список операндов пустым
    // ...Считать списки элементов левого и правого операндов пустыми

    // Если заданный узел есть унарная операция
        // Добавить в список операндов заданный узел и его операнд как родитель и операнд элемента соответственно
        // Вернуть список

    // Если заданный узел лист дерева
        // Добавить в список узлов заданный узел
        // Вернуть список

    // Если левый операнд заданного узла того же приоритета, что и заданный узел
        // Получить список элементов операторов одного приоритета, начиная с левого операнда заданного узла, без родителя у первого элемента
        // Добавить полученный список в список элементов левого операнда
    // Иначе добавить левый операнд в список элементов левого операнда

    // Если правый операнд заданного узла того же приоритета, что и заданный узел, несимметричный
        // Получить список элементов операторов одного приоритета, начиная с левого операнда заданного узла, без родителя у первого элемента
        // Добавить полученный список в список элементов правого операнда
    // Иначе добавить правый операнд в список правого операнда  элементов

    // Считать заданный узел родителем первого элемента списка элементов правого операнда

    // Добавить в список операндов списки левого и правого операндов заданного узла

    // Вернуть список операндов


    // Создать общего родителя для множителя : "*"
    NodeOfExprTree* parent = new NodeOfExprTree("*");

    // Создать указатель на операнд типа переменная
    NodeOfExprTree* operand_is_var = new NodeOfExprTree("variable");

    // Создать сравниваемую структуру типа переменной
    OperandOfExpr var = OperandOfExpr{parent, operand_is_var, false};

    QList<OperandOfExpr> list;
    list.append(var);

    return list;
}

/*!
 * \brief Получить список операндов, родители которых одного приоритета, начиная с заданного узла, раскрывая скобки
 * \param [in] is_invert - флаг: true - значение заданного узла необходимо поменять на противоположный операнд, false - иначе
 * \return список операндов
 */
QList<OperandOfExpr> NodeOfExprTree::getNodesOfSamePrecedenceWithParenthesesOpening(bool is_invert)
{
    // ...Считать список операндов пустым
    // ...Считать списки элементов левого и правого операндов пустыми

    // Если заданный узел есть унарная операция
        // Добавить в список операндов заданный узел и его операнд как родитель и операнд элемента соответственно
        // Вернуть список

    // Если заданный узел лист дерева
        // Добавить в список узлов заданный узел
        // Вернуть список

    // Если левый операнд заданного узла того же приоритета, что и заданный узел
        // Получить список элементов операторов одного приоритета с учётом инвертации, начиная с левого операнда заданного узла, без родителя у первого элемента
        // Добавить полученный список в список элементов левого операнда
    // Иначе добавить левый операнд в список элементов

    // Инвертировать тип заданного узла, если флаг установлен
    // Если заданный узел несимметричный оператор и флаг инвертации не установлен
        // Установить флаг инвертации
    // ИначеЕсли заданный узел симметричный оператор и флаг инвертации установлен
        // Убрать флаг инвертации

    // Если правый операнд заданного узла того же приоритета, что и заданный узел
        // Получить список элементов операторов одного приоритета с учётом инвертации, начиная с левого операнда заданного узла, без родителя у первого элемента
        // Добавить полученный список в список элементов правого операнда
    // Иначе добавить правый операнд в список правого операнда элементов

    // Считать заданный узел родителем первого элемента списка элементов правого операнда

    // Добавить в список операндов списки левого и правого операндов заданного узла

    // Вернуть список операндов

    // Создать общего родителя для множителя : "*"
    NodeOfExprTree* parent = new NodeOfExprTree("*");

    // Создать указатель на операнд типа переменная
    NodeOfExprTree* operand_is_var = new NodeOfExprTree("variable");

    // Создать сравниваемую структуру типа переменной
    OperandOfExpr var = OperandOfExpr{parent, operand_is_var, false};

    QList<OperandOfExpr> list;
    list.append(var);

    return list;
}

/*!
 * \brief Построить дерево выражения по элементам в списке
 * \param [in] list - список
 * \return указатель на корень дерева
 */
NodeOfExprTree* NodeOfExprTree::listToTree(QList<OperandOfExpr>& list)
{
    // Если первый элемент списка не является первым элементом дерева
    // Сделать первый элемент списка первым элементом дерева

    // Считать операнд первого элемента списка left_operand
    // Для каждого элемента списка кроме первого
    {
        // Если текущий элемент является первым элементом дерева
        // Создать симметричный узел того же приоритета и считать его родителем текущего узла
        // Установить left_operand как левый операнд родителя текущего элемента списка
        // Считать родитель текущего элемента списка left_operand
    }

    // Вернуть родитель последнего элемента

    NodeOfExprTree* left_operand = new NodeOfExprTree("1");
    return left_operand;
}

/*!
 * \brief Получить инфиксную запись выражения из дерева этого выражения
 * \param [in] is_first_elem - флаг: true - указанный узел является первым операндом родителя, false - иначе
 * \return строка инфиксной записи выражения
 */
QString& NodeOfExprTree::treeToInfix(bool is_first_elem)
{
    // ...Считать строку инфиксной записи пустой

    // Если заданный узел пустой
        // Вернуть пустую строку

    // Если у заданного узла есть левый операнд
        // Получить инфиксную запись левого операнда заданного узла, установив флаг первого элемента, если заданный оператор большего приоритета, чем левый операнд, или он уже установлен
    /* Если левый операнд заданного узла типа оператора унарный минус и не является первым элементом выражения
         или является узлом типа оператора меньшего приоритета, чем приоритет типа оператора заданного узла*/
        // Взять полученную запись в скобки
    // Добавить в инфиксную запись выражения получившуюся инфиксную запись левого операнда заданного узла

    // Добавить в инфиксную запись выражения значение заданного узла

    // Если у заданного узла есть правый операнд
        // Получить инфиксную запись правого операнда заданного узла, установив флаг первого элемента, если заданный оператор большего приоритета, чем правый операнд
    /* Если правый операнд заданного узла типа унарный минус или
        заданный узел есть несимметричный узел, а правый операнд типа оператора приоритета не больше заданного узла */
        // Взять полученную запись в скобки
    // Добавить в инфиксную запись выражения получившуюся инфиксную запись правого операнда заданного узла

    // Вернуть инфиксную запись выражения

    QString str("1");
    return str;
}

/*!
 * \brief Получить степень выражения
 * \return степень выражения
 */
int NodeOfExprTree::getDegreeOfExpr()
{
    // Считать степень выражения нулевой
    // Считать степень левого и правого операндов заданного узла нулевой

    // Считать степень равную единице, если заданный узел есть узел типа переменная, и вернуть её
    // Считать степень равную нулю, если заданный узел пустой или есть узел типа число, и вернуть её

    // Получить степени левого и правого операндов заданного узла

    // Если заданный узел есть типа оператора сложения или сравнения
        // Считать степень выражения максимальной среди степеней левого и правого операндов заданного узла
    // Иначе
        // Прибавить к степени выражения степень левого операнда заданного узла
    // Если заданный узел типа оператора деление
        // Отнять от степени выражения степень правого операнда заданного узла
    // Иначе
        // Прибавить от степени выражения степень правого операнда заданного узла

    // Вернуть степень выражения

    return 0;
}
